<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3.2高阶函数 p44</title>
</head>
<body>
<script src="http://test.zczj.com/js/jquery-1.11.0.min.js?v=20150401"></script>
    <script type="text/javascript">
        /*
        3.2.1 函数作为参数传递
        1. 回调函数
         */
        var getUserInfo = function(userId,callback) {
            $.ajax('http://xxx.com/getUserInfo?'+userId,function(data) {
                if (typeof callback === 'function') {
                    callback(data);
                }
            });
        }
        // getUserInfo(13157,function(data) {
        //     console.log(data.userName);
        // });
        /*
        回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这
        些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。
        比如，我们想在页面中创建 100个 div 节点，然后把这些 div 节点都设置为隐藏。下面是一种编写代码的方式:
         */
        var appendDiv = function() {
            for(var i=0;i<100;i++){
                var div = document.createElement('div');
                div.innerHTML= i;
                document.body.appendChild(div);
                div.style.display='none';
            }
        };
        appendDiv();
        /*
        把 div.style.display = 'none' 的逻辑硬编码在 appendDiv 里显然是不合理的， appendDiv 未免
        有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。
        于是我们把 div.style.display = 'none' 这行代码抽出来，用回调函数的形式传入 appendDiv
        方法：
         */
        var appendDiv = function (callback) {
            for(var i=0;i<100;i++){
                var div = document.createElement('div');
                div.innerHTML=i;
                document.body.appendChild(div);
                if (typeof callback === 'function') {
                    callback(div);
                }
            }
        }
        appendDiv(function(node) {
            node.style.display='inlineBlock';
            node.style.width=100+'px';
            node.style.height=100+'px';
            node.style.backgroundColor='pink';
            node.style.float='left';
            node.style.margin=2+'px';
            node.style.textAlign='center';
            node.style.lineHeight=100+'px';
            node.style.color='#193aae';
            node.style.fontSize=20+'px';
            node.style.fontWeight='blod';
        })

        //2.  Array.prototype.sort
        /*
        Array.prototype.sort 接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从
        Array.prototype.sort 的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使
        用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入
        Array.prototype.sort ，使 Array.prototype.sort 方法成为了一个非常灵活的方法，代码如下：
         */
         ;(function() {
             console.log([125,4,3].sort(function(a,b) {
                 return a-b;
             }));
             console.log([125,4,3].sort(function(a,b) {
                 return b-a;
             }));

         })();
         //p46
         //3.2.2 函数作为返回值输出
            //1. 判断数据的类型
            /*
            我们来看看这个例子，判断一个数据是否是数组，在以往的实现中，可以基于鸭子类型的概
            念来判断，比如判断这个数据有没有 length 属性，有没有 sort 方法或者 slice 方法等。但更好
            的方式是用 Object.prototype.toString 来计算。 Object.prototype.toString.call( obj ) 返回一个
            字 符 串 ， 比 如 Object.prototype.toString.call( [1,2,3] ) 总 是 返 回 "[object Array]" ， 而
            Object.prototype.toString.call( “str”) 总是返回 "[object String]" 。所以我们可以编写一系列的
            isType 函数。代码如下：
             */
            var isString = function (obj) {
                return Object.prototype.toString.call(obj) ==='[object String]';
            };
            var isArray = function(obj) {
                return Object.prototype.toString.call(obj) ==='[object Array]';
            };
            var isNumber = function(obj) {
                return Object.prototype.toString.call(obj) ==='[object Number]';
            }
            /*
            我们发现，这些函数的大部分实现都是相同的，不同的只是 Object.prototype.toString.
            call( obj ) 返回的字符串。为了避免多余的代码，我们尝试把这些字符串作为参数提前值入 isType
            函数。代码如下
             */
            var isType=function(type) {
                return function(obj) {
                    return Object.prototype.toString.call(obj) ==='[object '+type+']';
                }
            };
            var isString = isType('String');
            var isArray = isType('Array');
            var isNumber = isType('Number');
            console.log(isArray([1,2,3]));
            //我们还可以用循环语句，来批量注册这些 isType 函数：
            var Type={};
            for(var i = 0,type; type=['String','Array','Number'][i++];){
                (function(type) {
                    Type['is'+type]=function(obj) {
                        return Object.prototype.toString.call(obj) === '[object '+type+']';
                    }
                })(type)
            }
            console.log(Type.isArray([]));
            console.log(Type.isString("str"));

            //2.  getSingle 单例模式
            var getSingle = function(fn) {
                var ret;
                return function() {
                    return ret || (ret = fn.apply(this,arguments));
                };
            };
            /*
            这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。我们
            可以看看 getSingle 函数的效果：
             */
            var getScript = getSingle(function() {
                return document.createElement('script');
            });
            var script1= getScript();
            var script2 = getScript();
            console.log('=============================');
            console.log(script1===script2);

            //3.2.3 高阶函数实现AOP （面向切面编程）

            /*
                AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些
            跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，
            再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。
                通常，在 JavaScript中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具
            体的实现技术有很多，本节我们通过扩展 Function.prototype 来做到这一点。代码如下：
             */
            Function.prototype.before = function(beforefn) {
                var self=this;// 保存原函数的引用
                console.log(self);
                return function() { // 返回包含了原函数和新函数的"代理"函数
                    beforefn.apply(this,arguments); // 执行新函数，修正 this
                    return self.apply(this,arguments); // 执行并返回原函数
                }
            };

            Function.prototype.after = function(afterfn) {
                var self=this;
                console.log(self);
                return function() {
                    var ret = self.apply(this,arguments); // 执行原函数
                    afterfn.apply(this,arguments); // 执行新函数，修正 this
                    return ret; //返回原函数
                }
            };
            var func = function() {
                console.log(2);
            };
            func=func.before(function() {
                console.log(1);
            }).after(function() {
                console.log(3);
            });
            func();

            //3.2.4 高阶函数的其他应用 ===》高阶函数的其他应用
                //1.  currying 函数柯里化（function currying）
                /*
                    currying 又称部分求值。一个 currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。
                    假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱。代码如下：
                 */
            var monthlyCost =0;
            var cost = function(money) {
                monthlyCost+=money;
            };
            cost( 100 ); // 第 1 天开销
            cost( 200 ); // 第 2 天开销
            cost( 300 ); // 第 3 天开销
            //cost( 700 ); // 第 30 天开销
            console.log(monthlyCost); //600
            /*
            通过这段代码可以看到，每天结束后我们都会记录并计算到今天为止花掉的钱。但我们其实
            并不太关心每天花掉了多少钱，而只想知道到月底的时候会花掉多少钱。也就是说，实际上只需
            要在月底计算一次。
             */
            var cost=(function() {
                var args=[];
                return function() {
                    if (arguments.length===0) {
                        var money=0;
                        for(var i=0,l=args.length;i<l;i++){
                            money+=args[i];
                        }
                        return money;
                    }else{
                        [].push.apply(args,arguments);
                    }
                }
            })();
            //有点类似C#重载
            cost(100,200,200);
            cost(200);
            cost(300);
            console.log(cost());

            /*
            接下来我们编写一个通用的 function currying(){} ， function currying(){} 接受一个参数，即
            将要被 currying 的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。
            代码如下
             */
            var currying=function(fn) {
                // console.log(fn);
                var args=[];
                return function() {
                    if (arguments.length === 0) {
                        return fn.apply(this,args);
                    }else{
                        // console.log(arguments);
                        [].push.apply(args,arguments);
                        return arguments.callee;
                    }
                }
            };

            var cost=(function() {
                var money = 0;
                return function() {
                    for(var i=0,l=arguments.length;i<l;i++){
                        money+=arguments[i];
                    }
                    return money;
                }
            })();

            var cost=currying(cost); // 转化成 currying 函数
            // cost(100);
            // cost(200);
            // cost(300);
            cost(100,200,300);
            console.log(cost());//600
            /*
            至此，我们完成了一个 currying 函数的编写。当调用 cost() 时，如果明确地带上了一些参数，
            表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让 cost 函数返回另外一个
            函数。只有当我们以不带参数的形式执行 cost() 时，才利用前面保存的所有参数，真正开始进行
            求值计算。
             */

             //2.  uncurrying
             var obj1={
                name:'sven'
             };
             var obj2={
                getName:function() {
                    return this.name;
                }
             };
             console.log(obj2.getName.call(obj1)); // sven

             (function() {
                 Array.prototype.push.call(arguments,4);
                 console.log(arguments); //[1,2,3,4]
             })(1,2,3);

             /*
             那么有没有办法把泛化 this 的过程提取出来呢？本小节讲述的 uncurrying 就是用来解决这
             个问题的。 uncurrying 的话题来自 JavaScript之父 Brendan Eich在 2011年发表的一篇 Twitter。以
             下代码是 uncurrying 的实现方式之一：
              */
             Function.prototype.uncurrying=function() {
                 var self=this;
                 return function() {
                     var obj=Array.prototype.shift.call(arguments); //删除第1个参数并赋值给obj
                     // console.log(obj); //[1,2,3]
                     return self.apply(obj,arguments);
                 };
             };
             /*
             在讲解这段代码的实现原理之前，我们先来瞧瞧它有什么作用。
             在类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call
             这句代码转换为一个通用的 push 函数：
              */
             var push = Array.prototype.push.uncurrying();
             (function() {
                 push(arguments,4,20,10);
                 console.log(arguments); //[1,2,3,4]
             })(1,2,3);
             /*
             通过 uncurrying 的方式， Array.prototype.push.call 变成了一个通用的 push 函数。这样一来，
             push 函数的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而
             对于使用者而言，调用 push 函数的方式也显得更加简洁和意图明了。
             我们还可以一次性地把 Array.prototype 上的方法“复制”到 array 对象上，同样这些方法可
             操作的对象也不仅仅只是 array 对象：
              */
             for(var i=0,fn,ary=['push','shift','forEach'];fn=ary[i++];){
                Array[fn]=Array.prototype[fn].uncurrying();
             };
             var obj={
                "length":3,
                "0":1,
                "1":2,
                "2":3
             };
             Array.push(obj,4);
             console.log(obj.length);

             var first = Array.shift(obj);
             console.log(first);
             console.log(obj);
             Array.forEach(obj,function(i,n) {
                 console.log(n+ ': '+ i);
             })

    </script>
</body>
</html>